import sys
import socket
import threading

# Мы создаем строку HEXFILTER с печатными символами ASCII, если символ непечатный, вместо него выводится точка (.).
# В списковом включении (list comprehension), с помощью которого создается строка, применяется метод укороченного
# вычисления булевых выражений. Это означает: если длина символа, соответствующего целому числу в диапазоне 0...255,
# равна 3, мы берем сам символ (chr(i)), а если нет, то точку (.). Затем соединяем элементы списка в строку.
HEX_FILTER = ''.join([(len(repr(chr(i))) == 3) and chr(i) or '.' for i in range(256)])


# Определяем функцию hexdump, которая принимает ввод в виде байтов и выводит его в консоль в шестнадцатеричном формате.
# То есть она показывает содержимое пакетов и как шестнадцатеричные значения, и как печатные символы ASCII. Это помогает
# разобраться в неизвестных протоколах, обнаружить учетные данные пользователей, если взаимодействие не зашифровано, и
# многое другое.
# Эта функция дает возможность наблюдать за трафиком, проходящим через прокси-сервер, в режиме реального времени.
def hexdump(src, length=16, show=True):
    """
        Функция hexdump принимает ввод в виде байтов и выводит его в консоль в шестнадцатеричном формате.
        Она показывает содержимое пакетов и как шестнадцатеричные значения, и как печатные символы ASCII.
        Это помогает разобраться в неизвестных протоколах, обнаружить учетные данные пользователей,
        если взаимодействие не зашифровано, и многое другое.
        Эта функция дает возможность наблюдать за трафиком, проходящим через прокси-сервер, в режиме реального времени.

        Параметры:
        - src: исходные данные в виде байтов
        - length: количество байтов, выводимых на каждой строке (по умолчанию 16)
        - show: флаг, указывающий на необходимость вывода (по умолчанию True)

        Возвращает:
        - Если show=True, то возвращает None.
        - Если show=False, то возвращает список строк с шестнадцатеричным представлением данных.
    """
    # Проверяем, что мы получили строку, для этого декодируем строку байтов, если она была передана.
    if isinstance(src, bytes):
        src = src.decode()
    results = list()
    for i in range(0, len(src), length):
        # Берем часть строки, которую нужно вывести, и присваиваем ее переменной word.
        word = str(src[i:i + length])
        # Используем встроенную функцию translate, чтобы подставить вместо каждого символа в необработанной строке его
        # строковое представление (printable).
        printable = word.translate(HEX_FILTER)
        # Подставляем шестнадцатеричное представление целочисленного значения для каждого символа в исходной строке
        # (hexa).
        hexa = ' '.join([f'{ord(c):02X}' for c in word])
        hexwidth = length * 3
        # Cоздаем новый массив result для хранения строк, он будет содержать шестнадцатеричное значение индекса первого
        # байта в слове (word), шестнадцатеричное значение слова и его печатное представление.
        results.append(f'{i:04x} {hexa:<{hexwidth}} {printable}')
    if show:
        for line in results:
            print(line)
    else:
        return results


# Функция, которую программы на обоих концах прокси-сервера будут использовать для приема данных:
def receive_from(connection):
    """
        Функция receive_from принимает соединение от клиента и настраивает прокси-соединение
        с удаленным хостом и портом. Затем она перенаправляет данные между клиентом и сервером.

        Параметры:
        - connection: сокетное соединение с клиентом

        Возвращает:
        - Байтовая строка с полученными данными из сокета.
    """
    # Для получения как локальных, так и удаленных данных мы передаем объ- ект сокета, который будет использоваться в
    # дальнейшем. Создаем пустую байтовую строку buffer, в которой будут накапливаться ответы, получен- ные из сокета.
    buffer = b""
    # Мы указываем по умолчанию время ожидания длиной пять секунд (при необходимости можете его увеличить, поскольку,
    # если вы проксируете трафик в другие страны или по сетям с большими потерями, такое значение может оказаться
    # слишком жестким).
    connection.settimeout(5)
    try:
        # Цикл, чтобы записывать ответные данные в buffer, пока они не закончатся или не истечет время ожидания.
        while True:
            data = connection.recv(4096)
            if not data:
                break
            # Возвращаем байтовую строку buffer вызывающей стороне — ею может быть как локальная, так и удаленная
            # система.
            buffer += data
    except Exception as e:
        pass
    return buffer


# Иногда необходимо модифицировать пакеты запроса или ответа, прежде чем прокси-сервер отправит их по назначению.
# Добавим для этого две функции, request_handler и response_handler:

# Внутри этих функций можно изменять содержимое пакетов, заниматься фаззингом, отлаживать проблемы с аутентификацией —
# делать все, что вам угодно. Это может пригодиться, к примеру, если вы обнаружили передачу учетных данных в открытом
# виде и хотите попробовать повысить свои привилегии в ходе работы с приложением, передав ему admin вместо собственного
# имени пользователя.
def request_handler(buffer):
    """
        Функция request_handler принимает входные данные и модифицирует их, если необходимо.
        В данном примере функция не выполняет никаких операций, она просто возвращает полученный буфер.

        Параметры:
        - buffer: байтовая строка, содержащая входные данные

        Возвращает:
        Байтовую строку buffer, содержащую модифицированные данные
    """
    # модифицируем пакет
    return buffer


def response_handler(buffer):
    """
        Функция receive_from используется для приема данных как с локальной, так и с удаленной стороны.
        Она принимает объект сокета и получает данные, накапливая их в буфере.
        Возвращает байтовую строку, содержащую полученные данные.

        Параметры:
        - connection: объект сокета для приема данных

        Возвращает:
        Байтовую строку buffer, содержащую полученные данные
    """

    # модифицируем пакет
    return buffer


def proxy_handler(client_socket, remote_host, remote_port, receive_first):
    """
        Функция proxy_handler используется для установления прокси-соединения между клиентским и серверным сокетами.
        Она получает данные от клиента, отправляет их на удаленный хост, получает ответ от удаленного хоста
        и отправляет его обратно клиенту.

        Параметры:
        - client_socket: объект сокета для связи с клиентом
        - remote_host: IP-адрес удаленного хоста
        - remote_port: порт удаленного хоста
        - receive_first: флаг, указывающий на необходимость получения данных с удаленного хоста перед отправкой

        Возвращает:
        None
    """
    remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Подключаемся к удаленному узлу.
    remote_socket.connect((remote_host, remote_port))
    # Убеждаемся в том, что не нужно инициировать соединение с удаленной стороной и запрашивать данные, прежде чем
    # входить в главный цикл.Некоторые серверы ожидают этого от клиентов (например, FTP-серверы обычно вначале
    # отправляют приветственное сообщение).
    if receive_first:
        # Затем на обоих концах соединения используется функция receive_from. Она принимает объект соединенного сокета
        # и получает данные. Мы сохраняем содержимое пакета, чтобы позже его можно было проанализировать в поисках
        # чего-нибудь интересного.
        remote_buffer = receive_from(remote_socket)
        hexdump(remote_buffer)
    # Передаем вывод функции response_handler и отправляем принятый буфер локальному клиенту.
    remote_buffer = response_handler(remote_buffer)
    if len(remote_buffer):
        print("[<==] Sending %d bytes to localhost." % len(remote_buffer))
        client_socket.send(remote_buffer)
    # Цикл для непрерывного чтения данных локального клиента, обрабатываем прочитанное и передаем результат удаленному
    # клиенту, затем читаем ответ удаленного клиента, обрабатываем прочитанное и передаем результат локальному клиенту.
    while True:
        local_buffer = receive_from(client_socket)
        if len(local_buffer):
            line = "[==>]Received %d bytes from localhost." % len(local_buffer)
            print(line)
            hexdump(local_buffer)
            local_buffer = request_handler(local_buffer)
            remote_socket.send(local_buffer)
            print("[==>] Sent to remote.")
        remote_buffer = receive_from(remote_socket)
        if len(remote_buffer):
            print("[<==] Received %d bytes from remote." % len(remote_buffer))
            hexdump(remote_buffer)
            remote_buffer = response_handler(remote_buffer)
            client_socket.send(remote_buffer)
            print("[<==] Sent to localhost.")
        # Так продолжается до тех пор, пока данные не перестанут приходить. Когда больше нечего отправлять ни на одном
        # из концов соединения, мы закрываем локальный и удаленный сокеты и выходим из цикла.
        if not len(local_buffer) or not len(remote_buffer):
            client_socket.close()
            remote_socket.close()
            print("[*] No more data. Closing connections.")
            break


# Функцию server_loop для настройки соединения и управления им:
def server_loop(local_host, local_port, remote_host, remote_port, receive_first):
    """
        Функция server_loop является главным циклом прослушивания входящих соединений на локальном хосте.
        Она принимает параметры для настройки соединения и запускает прокси-обработчик для каждого входящего соединения.

        Параметры:
        - local_host: IP-адрес локального хоста для прослушивания входящих соединений
        - local_port: порт локального хоста для прослушивания входящих соединений
        - remote_host: IP-адрес удаленного хоста для перенаправления трафика
        - remote_port: порт удаленного хоста для перенаправления трафика
        - receive_first: флаг, указывающий на необходимость получения данных с удаленного хоста перед отправкой

        Возвращает:
        None
    """
    # Функция server_loop создает сокет.
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Этот сокет, привязывает его к локальному адресу и начинает прослушивать.
        server.bind((local_host, local_port))
    except Exception as e:
        print('problem on bind: %r' % e)
        print("[!!] Failed to listen on %s:%d" % (local_host, local_port))
        print("[!!] Check for other listening sockets or correct permissions.")
        sys.exit(0)
    print("[*] Listening on %s:%d" % (local_host, local_port))
    server.listen(5)
    # В главном цикле, когда приходит запрос на соединение, мы передаем его функции proxy_handler в новом потоке,
    # которая занимается отправкой и приемом битов на том или ином конце потока данных.
    while True:
        client_socket, addr = server.accept()
        # выводим информацию о локальном соединении
        line = "> Received incoming connection from %s:%d" % (addr[0], addr[1])
        print(line)
        # создаем поток для взаимодействия с удаленным сервером
        proxy_thread = threading.Thread(target=proxy_handler,
                                        args=(client_socket, remote_host, remote_port, receive_first))
        proxy_thread.start()


def main():
    """
        Функция main является точкой входа в программу.
        Она считывает аргументы командной строки, проверяет их и запускает основной цикл прослушивания.

        Параметры:
        Нет

        Возвращает:
        None
    """
    if len(sys.argv[1:]) != 5:
        print("Usage: ./proxy.py [localhost] [localport]", end='')
        print("[remotehost] [remoteport] [receive_first]")
        print("Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True")
        sys.exit(0)
    local_host = sys.argv[1]
    local_port = int(sys.argv[2])
    remote_host = sys.argv[3]
    remote_port = int(sys.argv[4])
    receive_first = sys.argv[5]
    if "True" in receive_first:
        receive_first = True
    else:
        receive_first = False
    server_loop(local_host, local_port, remote_host, remote_port, receive_first)


if __name__ == '__main__':
    main()
