"""Вам дано описание пирамиды из кубиков в формате XML.
Кубики могут быть трех цветов: красный (red), зеленый (green) и синий (blue).
Для каждого кубика известны его цвет, и известны кубики, расположенные прямо под ним.

Пример:

<cube color="blue">
  <cube color="red">
    <cube color="green">
    </cube>
  </cube>
  <cube color="red">
  </cube>
</cube>

Введем понятие ценности для кубиков. Самый верхний кубик, соответствующий корню XML документа имеет ценность 1. Кубики,
расположенные прямо под ним, имеют ценность 2. Кубики, расположенные прямо под нижележащими кубиками, имеют ценность 3.
И т. д.

Ценность цвета равна сумме ценностей всех кубиков этого цвета.

Выведите через пробел три числа: ценности красного, зеленого и синего цветов.
Sample Input:

<cube color="blue"><cube color="red"><cube color="green"></cube></cube><cube color="red"></cube></cube>

Sample Output:
4 3 1
"""

import xml.etree.ElementTree as ET


# Решение №1
# Первое решение использует модуль xml.etree.ElementTree для обработки XML-документа, описывающего пирамиду из кубиков.
# Решение реализовано с использованием рекурсии для обхода дерева кубиков. Каждому кубику присваивается ценность в
# соответствии с его уровнем в пирамиде. Затем вычисляются суммарные ценности для каждого цвета кубиков: красного,
# зеленого и синего. Результаты выводятся на экран.
########################################################################################################################

def calculate_values(root, level):
    values = {'red': 0, 'green': 0, 'blue': 0}  # Инициализируем словарь для хранения ценностей цветов

    # Обрабатываем текущий кубик
    color = root.attrib.get('color')  # Получаем значение атрибута 'color' текущего элемента
    values[color] += level  # Увеличиваем ценность цвета текущего элемента на уровень

    # Обрабатываем дочерние кубики
    for child in root:  # Итерируемся по дочерним элементам текущего элемента
        child_values = calculate_values(child, level + 1)  # Рекурсивно вызываем функцию для дочернего элемента
        for color, value in child_values.items():  # Итерируемся по цветам и их ценностям в дочерних элементах
            values[color] += value  # Увеличиваем ценность цвета текущего элемента на ценность из дочернего элемента

    return values  # Возвращаем словарь с ценностями цветов


xml_string = input("Введите XML-строку с описанием пирамиды: ")  # Ввод XML-строки с описанием пирамиды с клавиатуры

root = ET.fromstring(xml_string)  # Создаем XML-элемент из строки

color_values = calculate_values(root, 1)  # Вычисляем значения цветов с помощью функции calculate_values

print(color_values['red'], color_values['green'], color_values['blue'])  # Выводим результаты подсчета ценностей цветов

# Решение №2
# Второе решение также использует модуль xml.etree.ElementTree для обработки XML-документа с описанием пирамиды из
# кубиков. В этом решении также используется рекурсия для обхода дерева кубиков. Однако здесь реализация проще и более
# компактна. Каждому цвету кубика соответствует счетчик в словаре colors, который увеличивается на значение,
# соответствующее уровню кубика в пирамиде. В конце подсчитываются суммарные ценности для каждого цвета и выводятся на
# экран.
########################################################################################################################

root = ET.fromstring(input())  # Создаем XML-элемент из введенной XML-строки
colors = {"red": 0, "green": 0, "blue": 0}  # Инициализируем словарь для хранения ценностей цветов


def getcubes(root, value):
    colors[root.attrib['color']] += value  # Увеличиваем ценность цвета текущего элемента на значение
    for children in root:
        getcubes(children, value + 1)  # Рекурсивно вызываем функцию для дочерних элементов с увеличенным значением


getcubes(root, 1)  # Вызываем функцию для корневого элемента с начальным значением 1

print(colors["red"], colors["green"], colors["blue"])  # Выводим результаты подсчета ценностей цветов
