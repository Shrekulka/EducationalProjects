# editing_messages_of_different_types/handlers/user_handlers.py

from aiogram import Router, F, Bot
from aiogram.enums import ContentType
from aiogram.exceptions import TelegramBadRequest
from aiogram.filters import Command
from aiogram.types import (Message, CallbackQuery, InputMediaDocument, InputMediaVideo, InputMediaPhoto,
                           InputMediaAudio, InputMediaAnimation)

from keyboards.keyboard import get_markup
from lexicon.lexicon import LEXICON_RU, LEXICON
from logger_config import logger

# Инициализируем роутер уровня модуля
user_router: Router = Router()

# Переменная mode, которая будет хранить текущее значение режима. Например, в боте для мессенджера mode использоваться
# для определения того, какой тип мультимедийного контента будет отправлен или какой тип сообщения будет обработан в
# ответ на запрос пользователя.

# mode 1.1 - Меняет текст на текст, используется метод edit_text.
# mode 1.2 - Меняет текст на текст, используется метод edit_message_text у объекта бота (bot).

# mode 2.1 - Меняет фото на фото, используется метод edit_media.
# mode 2.2 - Меняет фото на фото, используется метод edit_message_media у объекта бота (bot).

# mode 3.1 - Меняет видео на видео, используется метод edit_media.
# mode 3.2 - Меняет видео на видео, используется метод edit_message_media у объекта бота (bot).

# mode 4.1 - Меняет аудио на аудио, используется метод edit_media.
# mode 4.2 - Меняет аудио на аудио, используется метод edit_message_media у объекта бота (bot).

# mode 5.1 - Меняет документ на документ, используется метод edit_media.
# mode 5.2 - Меняет документ на документ, используется метод edit_message_media у объекта бота (bot).

# mode 6.1 - Меняет аудио на фото, используется метод edit_media.
# mode 6.2 - Меняет аудио на фото, используется метод edit_message_media у объекта бота (bot).

# mode 7.1 - Меняет документ на видео и обратно, используется метод edit_media.
# mode 7.2 - Меняет документ на видео и обратно, используется метод edit_message_media у объекта бота (bot).

# mode 8.1 - Меняет анимацию на аудио и обратно, используется метод edit_media.
# mode 8.2 - Меняет анимацию на аудио и обратно, используется метод edit_message_media у объекта бота.

mode: float = 8.2

########################################################################################################################
# 1) Меняет текст на текст
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
if mode == 1.1 or mode == 1.2:
    # Этот обработчик будет вызываться при отправке команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """
           Обрабатывает команду "/start", отправляя сообщение с приветственным текстом и пользовательской клавиатурой.

           Args:
               message (Message): Объект сообщения, представляющий команду "/start".

           Returns:
               None

           Описание:
               Эта функция вызывается, когда пользователь отправляет команду "/start" боту. Сначала она выводит
               информацию об обновлении в терминал с помощью logger.info(). Затем создается новая клавиатура с помощью
               функции get_markup(), передавая ей необходимые параметры (в данном случае только 'text'). После этого
               функция отправляет сообщение пользователю с приветственным текстом из словаря LEXICON и созданной
               клавиатурой.
        """
        # Выводим информацию об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Создаем клавиатуру с новым текстом и старой клавиатурой
        markup = get_markup(1, 'text')

        # Отправляем сообщение с текстом из словаря и сгенерированной клавиатурой
        await message.answer(text=LEXICON['text_1'], reply_markup=markup)

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 1.1:
        # Этот обработчик будет вызываться при нажатии на инлайн-кнопку с callback_data - 'text' и меняет текст на текст
        @user_router.callback_query(F.data == 'text')
        async def process_button_press(callback: CallbackQuery) -> None:
            """
                Обрабатывает нажатие на инлайн-кнопку с callback_data 'text', редактируя текст сообщения на другой
                вариант.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.

                Returns:
                    None

                Описание:
                    Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'text'. Она
                    создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый параметр ('text').
                    Затем функция проверяет текущий текст сообщения и выбирает другой вариант текста из словаря LEXICON.
                    Наконец, она редактирует сообщение, заменяя текст и клавиатуру на новые значения.
            """
            # Создаем клавиатуру с новым текстом и старой клавиатурой
            markup = get_markup(1, 'text')

            # Проверяем текущий текст сообщения, чтобы определить, какой вариант текста использовать
            if callback.message.text == LEXICON['text_1']:
                # Если текущий текст соответствует первому варианту, меняем его на второй
                text = LEXICON['text_2']
            else:
                # Если текущий текст не соответствует первому варианту, меняем его на первый
                text = LEXICON['text_1']

            # Редактируем сообщение, заменяя его текст и клавиатуру
            await callback.message.edit_text(text=text, reply_markup=markup)

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 1.2:
        @user_router.callback_query(F.data == 'text')
        async def process_button_press(callback: CallbackQuery, bot: Bot) -> None:
            """
                Обрабатывает нажатие на инлайн-кнопку с callback_data 'text', редактируя текст сообщения на другой
                вариант.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.
                    bot (Bot): Объект бота, используемый для редактирования сообщения.
                Returns:
                    None

                Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'text'. Она
                    создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый параметр ('text').
                    Затем функция проверяет текущий текст сообщения и выбирает другой вариант текста из словаря LEXICON.
                    Наконец, она редактирует сообщение, заменяя текст и клавиатуру на новые значения.
            """
            # Получение разметки для клавиатуры с одним элементом типа "text"
            markup = get_markup(1, 'text')
            try:
                # Используется для редактирования существующего сообщения. Изменяет его содержимое, подпись и другие
                # атрибуты сообщения.
                await bot.edit_message_text(
                    chat_id=callback.message.chat.id,                   # ID чата
                    message_id=callback.message.message_id,             # ID сообщения
                    text=f"{LEXICON['text_1']}\n<em>Это текст 1</em>",  # Новый текст с подписью
                    reply_markup=markup)                                # Установка новой клавиатуры
            # В случае ошибки попытка изменить текст на другой текст
            except TelegramBadRequest:
                await bot.edit_message_text(
                    chat_id=callback.message.chat.id,                   # ID чата
                    message_id=callback.message.message_id,             # ID сообщения
                    text=f"{LEXICON['text_2']}\n<em>Это текст 2</em>",  # Новый текст с подписью
                    reply_markup=markup)                                # Установка новой клавиатуры

########################################################################################################################
# 2) Меняет фото на фото
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
elif mode == 2.1 or mode == 2.2:
    # Определение обработчика для команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """
            Обрабатывает команду "/start", отправляя сообщение с фотографией, текстом и пользовательской клавиатурой.

            Args:
                message (Message): Объект сообщения, представляющий команду "/start".

            Returns:
                None

            Описание:
                Эта функция вызывается, когда пользователь отправляет команду "/start" боту. Сначала она выводит
                информацию об обновлении в терминал с помощью logger.info(). Затем создается новая клавиатура с помощью
                функции get_markup(), передавая ей необходимые параметры (в данном случае только 'photo'). После этого
                функция отправляет сообщение пользователю с фотографией из словаря LEXICON и созданной клавиатурой.
        """
        # Вывод информации об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Получение разметки для клавиатуры с одним элементом типа "photo"
        markup = get_markup(1, 'photo')

        # Отправка сообщения с фотографией, текстом и клавиатурой
        await message.answer_photo(
            photo=LEXICON['photo_id1'],  # Идентификатор фотографии для отправки
            caption='Это фото 1',        # Подпись к фотографии
            reply_markup=markup)         # Клавиатура, прикрепленная к сообщению


    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 2.1:
        # 1) В этом подходе используется метод edit_media у объекта сообщения (callback.message), чтобы заменить текущее
        # медиа на новую фотографию. В этом случае необходимо передавать только параметры изменяемого контента.
        @user_router.callback_query(F.data == 'photo')
        async def process_button_press(callback: CallbackQuery) -> None:
            """
                Обрабатывает нажатие на инлайн-кнопку с callback_data 'photo', редактируя фотографию и текст сообщения.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.

                Returns:
                    None

                Описание:
                    Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'photo'.
                    Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый параметр
                    ('photo'). Затем функция пытается изменить медиа в сообщении на новую фотографию с соответствующим
                    текстом из словаря LEXICON. Если возникает ошибка, она изменяет медиа на другую фотографию с
                    соответствующим текстом.
            """
            # Получение разметки для клавиатуры с одним элементом типа "photo"
            markup = get_markup(1, 'photo')
            try:
                # Попытка изменить медиа в сообщении на новую фотографию с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaPhoto, который является медиа-контентом - фотография.
                    media=InputMediaPhoto(
                        media=LEXICON['photo_id2'],  # ID новой фотографии
                        caption='Это фото 2'),       # Подпись к новой фотографии
                    reply_markup=markup)             # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другую фотографию с соответствующим текстом
            except TelegramBadRequest:
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaPhoto, который является медиа-контентом - фотография.
                    media=InputMediaPhoto(
                        media=LEXICON['photo_id1'],  # ID первой фотографии
                        caption='Это фото 1'),       # Подпись к первой фотографии
                    reply_markup=markup)             # Установка клавиатуры

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    elif mode == 2.2:
        # 2) В этом подходе используется метод edit_message_media у объекта бота (bot), который редактирует сообщение по
        # его chat_id и message_id. Этот метод позволяет явно указать сообщение, которое необходимо изменить, и передать
        # как новый контент, так и новую клавиатуру.
        @user_router.callback_query(F.data == 'photo')
        async def process_button_press(callback: CallbackQuery, bot: Bot):
            """
                Обрабатывает нажатие на инлайн-кнопку с callback_data 'photo', редактируя фотографию и текст сообщения.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.
                    bot (Bot): Объект бота, используемый для редактирования сообщения.

                Returns:
                    None

                Описание:
                    Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'photo'.
                    Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый параметр
                    ('photo'). Затем функция пытается изменить медиа в сообщении на новую фотографию с соответствующим
                    текстом из словаря LEXICON. Если возникает ошибка, она изменяет медиа на другую фотографию с
                    соответствующим текстом.
            """
            # Получение разметки для клавиатуры с одним элементом типа "photo"
            markup = get_markup(1, 'photo')
            try:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaPhoto, который является медиа-контентом - фотография.
                    media=InputMediaPhoto(
                        media=LEXICON['photo_id2'],  # ID новой фотографии
                        caption='Это фото 2'),       # Подпись к новой фотографии
                    reply_markup=markup)             # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другую фотографию с соответствующим текстом
            except TelegramBadRequest:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaPhoto, который является медиа-контентом - фотография.
                    media=InputMediaPhoto(
                        media=LEXICON['photo_id1'],  # ID первой фотографии
                        caption='Это фото 1'),       # Подпись к первой фотографии
                    reply_markup=markup)             # Установка клавиатуры

########################################################################################################################
# 3) Меняет видео на видео
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
elif mode == 3.1 or mode == 3.2:
    # Определение обработчика для команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """
            Обрабатывает команду "/start", отправляя сообщение с видео, текстом и клавиатурой.

            Args:
                message (Message): Объект сообщения, представляющий команду "/start".

            Returns:
                None

            Описание:
                Эта функция вызывается, когда пользователь отправляет команду "/start" боту. Выводит информацию об
                апдейте в терминал с помощью logger.info(). Затем создает клавиатуру с одним элементом типа "video" с
                помощью функции get_markup(). После чего отправляет сообщение с видео, текстом и клавиатурой.
        """
        # Вывод информации об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Создание клавиатуры с новым текстом и старой клавиатурой
        markup = get_markup(1, 'video')

        # Отправка сообщения с видео, текстом и клавиатурой
        await message.answer_video(
            video=LEXICON['video_id1'],  # ID видео для отправки
            caption='Это видео 1',       # Подпись к видео
            reply_markup=markup)         # Клавиатура, прикрепленная к сообщению

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 3.1:
        # 1) В этом подходе используется метод edit_media у объекта сообщения (callback.message), чтобы заменить текущее
        # медиа на новое видео. В этом случае необходимо передавать только параметры изменяемого контента.
        @user_router.callback_query(F.data == 'video')
        async def process_button_press(callback: CallbackQuery) -> None:
            """
               Обрабатывает нажатие на инлайн-кнопку с callback_data 'video', редактируя видео и текст сообщения.

               Args:
                   callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.

               Returns:
                   None

               Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'video'.
                   Пытается изменить медиа в сообщении на новое видео с соответствующим текстом из словаря LEXICON. Если
                   возникает ошибка, изменяет медиа на другое видео с соответствующим текстом.
            """
            # Получение разметки для клавиатуры с одним элементом типа "video"
            markup = get_markup(1, 'video')
            try:
                # Попытка изменить медиа в сообщении на новое видео с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaVideo, который является медиа-контентом - видео.
                    media=InputMediaVideo(
                        media=LEXICON['video_id2'],  # ID нового видео
                        caption='Это видео 2'),      # Подпись к новому видео
                    reply_markup=markup)             # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другое видео с соответствующим текстом
            except TelegramBadRequest:
                # Попытка изменить медиа в сообщении на другое видео с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaVideo, который является медиа-контентом - видео.
                    media=InputMediaVideo(
                        media=LEXICON['video_id1'],  # ID первого видео
                        caption='Это видео 1'),      # Подпись к первому видео
                    reply_markup=markup)             # Установка клавиатуры

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    elif mode == 3.2:
        # 2) В этом подходе используется метод edit_message_media у объекта бота (bot), который редактирует сообщение по
        # его chat_id и message_id. Этот метод позволяет явно указать сообщение, которое необходимо изменить, и передать
        # как новый контент, так и новую клавиатуру.
        @user_router.callback_query(F.data == 'video')
        async def process_button_press(callback: CallbackQuery, bot: Bot) -> None:
            """
               Обрабатывает нажатие на инлайн-кнопку с callback_data 'video', редактируя видео и текст сообщения.

               Args:
                   callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.
                   bot (Bot): Объект бота, используемый для редактирования сообщения.

               Returns:
                   None

               Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'video'.
                   Пытается изменить медиа в сообщении на новое видео с соответствующим текстом из словаря LEXICON. Если
                   возникает ошибка, изменяет медиа на другое видео с соответствующим текстом.
            """
            # Получение разметки для клавиатуры с одним элементом типа "video"
            markup = get_markup(1, 'video')
            try:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaVideo, который является медиа-контентом - видео.
                    media=InputMediaVideo(
                        media=LEXICON['video_id2'],  # ID нового видео
                        caption='Это видео 2'),      # Подпись к новому видео
                    reply_markup=markup)             # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другое видео с соответствующим текстом
            except TelegramBadRequest:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaVideo, который является медиа-контентом - видео.
                    media=InputMediaVideo(
                        media=LEXICON['video_id1'],  # ID первого видео
                        caption='Это видео 1'),      # Подпись к первому видео
                    reply_markup=markup)             # Установка клавиатуры

########################################################################################################################
# 4) Меняет аудио на аудио
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
elif mode == 4.1 or mode == 4.2:
    # Определение обработчика для команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """
            Обрабатывает команду "/start", отправляя сообщение с аудио, текстом и клавиатурой.

            Args:
                message (Message): Объект сообщения, представляющий команду "/start".

            Returns:
                None

            Описание:
                Эта функция вызывается, когда пользователь отправляет команду "/start" боту. Выводит информацию об
                апдейте в терминал с помощью logger.info(). Затем создает клавиатуру с одним элементом типа "audio" с
                помощью функции get_markup(). После чего отправляет сообщение с аудио, текстом и клавиатурой.
        """
        # Вывод информации об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Создание клавиатуры с новым текстом и старой клавиатурой
        markup = get_markup(1, 'audio')

        # Отправка сообщения с аудио, текстом и клавиатурой
        await message.answer_audio(
            audio=LEXICON['audio_id1'],  # Идентификатор аудио для отправки
            caption='Это аудио 1',       # Подпись к аудио
            reply_markup=markup)         # Клавиатура, прикрепленная к сообщению


    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 4.1:
        # 1) В этом подходе используется метод edit_media у объекта сообщения (callback.message), чтобы заменить текущее
        # медиа на новое аудио. В этом случае необходимо передавать только параметры изменяемого контента.
        @user_router.callback_query(F.data == 'audio')
        async def process_button_press(callback: CallbackQuery) -> None:
            """
               Обрабатывает нажатие на инлайн-кнопку с callback_data 'audio', редактируя аудио и текст сообщения.

               Args:
                   callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.

               Returns:
                   None

               Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'audio'.
                   Пытается изменить медиа в сообщении на новое аудио с соответствующим текстом из словаря LEXICON. Если
                   возникает ошибка, изменяет медиа на другое аудио с соответствующим текстом.
            """
            # Получение разметки для клавиатуры с одним элементом типа "audio"
            markup = get_markup(1, 'audio')
            try:
                # Попытка изменить медиа в сообщении на новое аудио с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaAudio, который является медиа-контентом - аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id2'],  # ID нового аудио
                        caption='Это аудио 2'),      # Подпись к новому аудио
                    reply_markup=markup)             # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другое аудио с соответствующим текстом
            except TelegramBadRequest:
                # Попытка изменить медиа в сообщении на другое аудио с соответствующим текстом.
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaAudio, который является медиа-контентом - аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id1'],  # ID первого аудио
                        caption='Это аудио 1'),      # Подпись к первому аудио
                    reply_markup=markup)             # Установка клавиатуры

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    elif mode == 4.2:
        # 2) В этом подходе используется метод edit_message_media у объекта бота (bot), который редактирует сообщение по
        # его chat_id и message_id. Этот метод позволяет явно указать сообщение, которое необходимо изменить, и передать
        # как новый контент, так и новую клавиатуру.
        @user_router.callback_query(F.data == 'audio')
        async def process_button_press(callback: CallbackQuery, bot: Bot) -> None:
            """
               Обрабатывает нажатие на инлайн-кнопку с callback_data 'audio', редактируя аудио и текст сообщения.

               Args:
                   callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.
                   bot (Bot): Объект бота, используемый для редактирования сообщения.

               Returns:
                   None

               Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'audio'.
                   Пытается изменить медиа в сообщении на новое аудио с соответствующим текстом из словаря LEXICON. Если
                   возникает ошибка, изменяет медиа на другое аудио с соответствующим текстом.
            """
            # Получение разметки для клавиатуры с одним элементом типа "audio"
            markup = get_markup(1, 'audio')
            try:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaAudio, который является медиа-контентом - аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id2'],  # ID нового аудио
                        caption='Это аудио 2'),      # Подпись к новому аудио
                    reply_markup=markup)             # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другое аудио с соответствующим текстом
            except TelegramBadRequest:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaAudio, который является медиа-контентом - аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id1'],  # ID первого аудио
                        caption='Это аудио 1'),      # Подпись к первому аудио
                    reply_markup=markup)             # Установка клавиатуры

########################################################################################################################
# 5) Меняет документ на документ
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
elif mode == 5.1 or mode == 5.2:
    # Определение обработчика для команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """
            Обрабатывает команду "/start", отправляя сообщение с документом и клавиатурой.

            Args:
                message (Message): Объект сообщения, представляющий команду "/start".

            Returns:
                None

            Описание:
                Эта функция вызывается, когда пользователь отправляет команду "/start" боту. Она выводит информацию об
                обновлении в терминал, создает новую клавиатуру и отправляет сообщение пользователю с документом из
                словаря LEXICON и созданной клавиатурой.
        """
        # Вывод информации об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Создание клавиатуры с новым текстом и старой клавиатурой
        markup = get_markup(1, 'document')

        # Отправка сообщения с документом, текстом и клавиатурой
        await message.answer_document(
            document=LEXICON['document_id1'],  # Идентификатор документа для отправки
            caption='Это документ 1',          # Подпись к документу
            reply_markup=markup)               # Клавиатура, прикрепленная к сообщению

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 5.1:
        # 1) В этом подходе используется метод edit_media у объекта сообщения (callback.message), чтобы заменить текущее
        # медиа на новый документ. В этом случае необходимо передавать только параметры изменяемого контента.
        @user_router.callback_query(F.data == 'document')
        async def process_button_press(callback: CallbackQuery) -> None:
            """
                Обрабатывает нажатие на инлайн-кнопку с callback_data 'document', редактируя сообщение на другой
                документ.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.

                Returns:
                    None

                Описание:
                    Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'document'.
                    Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый параметр
                    ('document'). Затем функция пытается изменить медиа в сообщении на новый документ из словаря
                    LEXICON. Если возникает ошибка, она пытается изменить медиа на другой документ.
            """
            # Получение разметки для клавиатуры с одним элементом типа "document"
            markup = get_markup(1, 'document')
            try:
                # Попытка изменить медиа в сообщении на новый документ с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaDocument, который является медиа-контентом - документом.
                    media=InputMediaDocument(
                        media=LEXICON['document_id2'],  # ID нового документа
                        caption='Это документ 2'),      # Подпись к новому документу
                    reply_markup=markup)                # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другой документ с соответствующим текстом
            except TelegramBadRequest:
                # Попытка изменить медиа в сообщении на другой документ с соответствующим текстом.
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaDocument, который является медиа-контентом - документом.
                    media=InputMediaDocument(
                        media=LEXICON['document_id1'],  # ID первого документа
                        caption='Это документ 1'),      # Подпись к первому документу
                    reply_markup=markup)                # Установка клавиатуры

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    elif mode == 5.2:
        # 2) В этом подходе используется метод edit_message_media у объекта бота (bot), который редактирует сообщение по
        # его chat_id и message_id. Этот метод позволяет явно указать сообщение, которое необходимо изменить, и передать
        # как новый контент, так и новую клавиатуру.
        @user_router.callback_query(F.data == 'document')
        async def process_button_press(callback: CallbackQuery, bot: Bot) -> None:
            """
               Обрабатывает нажатие на инлайн-кнопку с callback_data 'document', редактируя сообщение на другой
               документ.

               Args:
                   callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.
                   bot (Bot): Объект бота.

               Returns:
                   None

               Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'document'. Она
                   создает новую клавиатуру с помощью функции get_markup() и пытается изменить медиа в сообщении на
                   новый документ. В случае ошибки, она пытается изменить медиа на другой документ.
            """
            # Получение разметки для клавиатуры с одним элементом типа "document"
            markup = get_markup(1, 'document')
            try:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaDocument, который является медиа-контентом - документом.
                    media=InputMediaDocument(
                        media=LEXICON['document_id2'],  # ID нового документа
                        caption='Это документ 2'),      # Подпись к новому документу
                    reply_markup=markup)                # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другой документ с соответствующим текстом
            except TelegramBadRequest:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaDocument, который является медиа-контентом - документом.
                    media=InputMediaDocument(
                        media=LEXICON['document_id1'],  # ID первого документа
                        caption='Это документ 1'),      # Подпись к первому документу
                    reply_markup=markup)                # Установка клавиатуры

########################################################################################################################
# 6) Меняет аудио на фото и обратно
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
elif mode == 6.1 or mode == 6.2:
    # Определение обработчика для команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """ Обрабатывает команду "/start", выводит информацию об апдейте и отправляет аудио с клавиатурой типа "photo"

           Args:
            message (Message): Объект сообщения.

            Returns:
                None

            Описание:
                Эта функция вызывается при отправке команды "/start" боту. Она выводит информацию об обновлении в
                терминал, создает новую клавиатуру и отправляет сообщение пользователю с аудио из словаря LEXICON и
                созданной клавиатурой.
        """
        # Вывод информации об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Создание клавиатуры с новым текстом и старой клавиатурой
        markup = get_markup(1, 'photo')

        # Отправка сообщения с аудио, текстом и клавиатурой
        await message.answer_audio(
            audio=LEXICON['audio_id1'],  # ID аудио для отправки
            caption='Это аудио 1',       # Подпись к аудио
            reply_markup=markup)         # Клавиатура, прикрепленная к сообщению

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 6.1:
        # 1) В этом подходе используется метод edit_media у объекта сообщения (callback.message), чтобы заменить текущее
        # медиа на новое фото. В этом случае необходимо передавать только параметры изменяемого контента.
        @user_router.callback_query(F.data.in_(['audio', 'photo']))
        async def process_button_press(callback: CallbackQuery) -> None:
            """
                Обрабатывает нажатие кнопки с callback_data 'audio' или 'photo' и изменяет медиа в сообщении
                соответственно.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery.

                Returns:
                    None

                Описание:
                    Эта функция вызывается при нажатии на кнопку с callback_data 'audio' или 'photo'. Она пытается
                    изменить медиа в сообщении на новое аудио или фото из словаря LEXICON в зависимости от нажатой
                    кнопки. Если возникает ошибка, она изменяет медиа на другое аудио или фото.
            """
            # Получение разметки для клавиатуры с одним элементом типа "document" и "video"
            markup_audio = get_markup(1, 'audio')
            markup_photo = get_markup(1, 'photo')
            try:
                # Попытка изменить медиа в сообщении на новое фото с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaPhoto, который является медиа-контентом - фото.
                    media=InputMediaPhoto(
                        media=LEXICON['photo_id2'],  # ID нового фото
                        caption='Это фото 2'),       # Подпись к новому фото
                    reply_markup=markup_audio)       # Установка новой клавиатуры

            # В случае ошибки попытка изменить медиа на другое аудио с соответствующим текстом
            except TelegramBadRequest:
                # Попытка изменить медиа в сообщении на другое аудио с соответствующим текстом.
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaAudio, который является медиа-контентом - аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id2'],  # ID первого аудио
                        caption='Это аудио 2'),      # Подпись к первому аудио
                    reply_markup=markup_photo)       # Установка клавиатуры

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    elif mode == 6.2:
        # 2) В этом подходе используется метод edit_message_media у объекта бота (bot), который редактирует сообщение по
        # его chat_id и message_id. Этот метод позволяет явно указать сообщение, которое необходимо изменить, и передать
        # как новый контент, так и новую клавиатуру.
        @user_router.callback_query(F.data.in_(['audio', 'photo']))
        async def process_button_press(callback: CallbackQuery, bot: Bot):
            """
                Обрабатывает нажатие на инлайн-кнопку с callback_data 'photo' или 'audio' редактируя сообщение на
               другое аудио или фото.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery.
                    bot (Bot): Объект бота.

                Returns:
                    None

                Описание:
                    Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'audio' или
                   'photo'. Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый
                   параметр ('audio' или 'photo'). Затем функция пытается изменить медиа в сообщении на новое фото
                   из словаря LEXICON. Если возникает ошибка, она пытается изменить медиа на другое аудио.
            """
            # Получение разметки для клавиатуры с одним элементом типа "document"
            markup_audio = get_markup(1, 'audio')
            markup_photo = get_markup(1, 'photo')

            try:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaPhoto, который является медиа-контентом - фото.
                    media=InputMediaPhoto(
                        media=LEXICON['photo_id1'],  # ID нового фото
                        caption='Это фото 1'),       # Подпись к новому фото
                    reply_markup=markup_audio)       # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другое фото с соответствующим текстом
            except TelegramBadRequest:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaAudio, который является медиа-контентом - аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id1'],  # ID первого аудио
                        caption='Это аудио 1'),      # Подпись к первому аудио
                    reply_markup=markup_photo)       # Установка клавиатуры

########################################################################################################################
# 7) Меняет документ на видео, а видео на документ
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
elif mode == 7.1 or mode == 7.2:
    # Определение обработчика для команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """
           Обрабатывает команду "/start", отправляя сообщение с документом и пользовательской клавиатурой.

           Args:
               message (Message): Объект сообщения, представляющий команду "/start".

           Returns:
               None

           Описание:
               Эта функция вызывается, когда пользователь отправляет команду "/start" боту. Сначала она выводит
               информацию об обновлении в терминал с помощью logger.info(). Затем создается новая клавиатура с помощью
               функции get_markup(), передавая ей необходимый параметр ('video'). После этого функция отправляет
               сообщение пользователю с документом из словаря LEXICON и созданной клавиатурой.
        """
        # Вывод информации об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Создание клавиатуры с новым текстом и старой клавиатурой
        markup_video = get_markup(1, 'video')
        # Отправка сообщения с документом, текстом и клавиатурой
        await message.answer_document(
            document=LEXICON['document_id1'],  # Идентификатор документа для отправки
            caption='Это документ 1',          # Подпись к документу
            reply_markup=markup_video)      # Клавиатура, прикрепленная к сообщению

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 7.1:
        # 1) В этом подходе используется метод edit_media у объекта сообщения (callback.message), чтобы заменить текущее
        # медиа на новое видео. В этом случае необходимо передавать только параметры изменяемого контента.
        @user_router.callback_query(F.data.in_(['document', 'video']))
        async def process_button_press(callback: CallbackQuery) -> None:
            """
                Обрабатывает нажатие на инлайн-кнопку с callback_data 'document' или 'video', редактируя сообщение на
                другой документ или видео.

                Args:
                    callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.

                Returns:
                    None

                Описание:
                    Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'document' или
                    'video'. Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый
                    параметр ('document' или 'video'). Затем функция пытается изменить медиа в сообщении на новое видео
                    из словаря LEXICON. Если возникает ошибка, она пытается изменить медиа на другой документ.
            """
            # Получение разметки для клавиатуры с одним элементом типа "document" и "video"
            markup_document = get_markup(1, 'document')
            markup_video = get_markup(1, 'video')
            try:
                # Попытка изменить медиа в сообщении на новое видео с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaVideo, который является медиа-контентом - видео.
                    media=InputMediaVideo(
                        media=LEXICON['video_id1'],  # ID нового видео
                        caption='Это видео 1'),      # Подпись к новому видео
                    reply_markup=markup_document)    # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другой документ с соответствующим текстом
            except TelegramBadRequest:
                # Попытка изменить медиа в сообщении на другой документ с соответствующим текстом.
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaDocument, который является медиа-контентом - документом.
                    media=InputMediaDocument(
                        media=LEXICON['document_id1'],  # ID первого документа
                        caption='Это документ 1'),      # Подпись к первому документу
                    reply_markup=markup_video)          # Установка клавиатуры

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    elif mode == 7.2:
        # 2) В этом подходе используется метод edit_message_media у объекта бота (bot), который редактирует сообщение по
        # его chat_id и message_id. Этот метод позволяет явно указать сообщение, которое необходимо изменить, и передать
        # как новый контент, так и новую клавиатуру.
        @user_router.callback_query(F.data.in_(['document', 'video']))
        async def process_button_press(callback: CallbackQuery, bot: Bot) -> None:
            """
               Обрабатывает нажатие на инлайн-кнопку с callback_data 'document' или 'video', редактируя сообщение на
               другой документ или видео.

               Args:
                   callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.
                   bot (Bot): Объект бота, используемый для редактирования сообщения.

               Returns:
                   None

               Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'document' или
                   'video'. Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый
                   параметр ('document' или 'video'). Затем функция пытается изменить медиа в сообщении на новое видео
                   из словаря LEXICON. Если возникает ошибка, она пытается изменить медиа на другой документ.
            """
            # Получение разметки для клавиатуры с одним элементом типа "document"
            markup_document = get_markup(1, 'document')
            markup_video = get_markup(1, 'video')
            try:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaDocument, который является медиа-контентом - документом.
                    media=InputMediaDocument(
                        media=LEXICON['document_id2'],  # ID нового документа
                        caption='Это документ 2'),      # Подпись к новому документу
                    reply_markup=markup_video)          # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другое видео с соответствующим текстом
            except TelegramBadRequest:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaDocument, который является медиа-контентом - документом.
                    media=InputMediaDocument(
                        media=LEXICON['video_id2'],  # ID первого видео
                        caption='Это видео 2'),      # Подпись к первому видео
                    reply_markup=markup_document)    # Установка клавиатуры


########################################################################################################################
# 8) Меняет анимацию на аудио и обратно
########################################################################################################################
# Проверяем значение переменной mode, чтобы определить текущий режим работы.
elif mode == 8.1 or mode == 8.2:
    # Определение обработчика для команды "/start"
    @user_router.message(Command(commands=["start"]))
    async def process_start_command(message: Message) -> None:
        """
            Обрабатывает команду "/start", отправляя сообщение с анимацией и пользовательской клавиатурой.

            Args:
                message (Message): Объект сообщения, представляющий команду "/start".

            Returns:
                None

            Описание:
                Эта функция вызывается, когда пользователь отправляет команду "/start" боту. Сначала она выводит
                информацию об обновлении в терминал с помощью logger.info(). Затем создается новая клавиатура с помощью
                функции get_markup(), передавая ей необходимый параметр ('audio'). После этого функция отправляет
                сообщение пользователю с анимацией из словаря LEXICON и созданной клавиатурой.
        """
        # Вывод информации об апдейте в терминал
        logger.info(message.model_dump_json(indent=4, exclude_none=True))

        # Создание клавиатуры с новым текстом и старой клавиатурой
        markup_audio = get_markup(1, 'audio')
        # Отправка сообщения с анимацией, текстом и клавиатурой
        await message.answer_animation(
            animation=LEXICON['animation_id1'],  # Идентификатор анимации для отправки
            reply_markup=markup_audio)           # Клавиатура, прикрепленная к сообщению

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    if mode == 8.1:
        # 1) В этом подходе используется метод edit_media у объекта сообщения (callback.message), чтобы заменить текущее
        # медиа на новое аудио. В этом случае необходимо передавать только параметры изменяемого контента.
        @user_router.callback_query(F.data.in_(['animation', 'audio']))
        async def process_button_press(callback: CallbackQuery) -> None:
            """
               Обрабатывает нажатие на инлайн-кнопку с callback_data 'animation' или 'audio', редактируя сообщение на
               другое аудио или анимацию.

               Args:
                   callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.

               Returns:
                   None

               Описание:
                   Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'animation'
                   или 'audio'. Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый
                   параметр ('animation' или 'audio'). Затем функция пытается изменить медиа в сообщении на новое
                   аудио из словаря LEXICON. Если возникает ошибка, она пытается изменить медиа на другую анимацию.
            """
            # Получение разметки для клавиатуры с одним элементом типа "animation" и "audio"
            markup_animation = get_markup(1, 'animation')
            markup_audio = get_markup(1, 'audio')
            try:
                # Попытка изменить медиа в сообщении на новое аудио с соответствующим текстом
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaAudio, который является аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id1'],  # ID аудио
                        caption='Это аудио 1'),      # Подпись к новому аудио
                    reply_markup=markup_animation)   # Установка новой клавиатуры
            # В случае ошибки попытка изменить медиа на другое аудио с соответствующим текстом
            except TelegramBadRequest:
                # Попытка изменить медиа в сообщении на другое аудио с соответствующим текстом.
                await callback.message.edit_media(
                    # Cоздается объект media типа InputMediaAnimation, который является медиа-контентом - анимацией.
                    media=InputMediaAnimation(
                        media=LEXICON['animation_id1'],  # ID первой анимации
                        caption='Это анимация 1'),       # Подпись к первой анимации
                    reply_markup=markup_audio)           # Установка клавиатуры

    # Проверяем значение переменной mode, чтобы определить текущий режим работы.
    elif mode == 8.2:
        # 2) В этом подходе используется метод edit_message_media у объекта бота (bot), который редактирует сообщение по
        # его chat_id и message_id. Этот метод позволяет явно указать сообщение, которое необходимо изменить, и передать
        # как новый контент, так и новую клавиатуру.
        @user_router.callback_query(F.data.in_(['animation', 'audio']))
        async def process_button_press(callback: CallbackQuery, bot: Bot) -> None:
            """
              Обрабатывает нажатие на инлайн-кнопку с callback_data 'animation' или 'audio', редактируя сообщение на
              другое аудио или анимацию.

              Args:
                  callback (CallbackQuery): Объект CallbackQuery, представляющий нажатие на инлайн-кнопку.
                  bot (Bot): Объект бота, используемый для редактирования сообщения.

              Returns:
                  None

              Описание:
                  Эта функция вызывается, когда пользователь нажимает на инлайн-кнопку с callback_data 'animation'
                  или 'audio'. Она создает новую клавиатуру с помощью функции get_markup(), передавая ей необходимый
                  параметр ('animation' или 'audio'). Затем функция пытается изменить медиа в сообщении на новое
                  аудио из словаря LEXICON. Если возникает ошибка, она пытается изменить медиа на другую анимацию.
            """
            # Получение разметки для клавиатуры с одним элементом типа "audio" и "animation"
            markup_animation = get_markup(1, 'animation')
            markup_audio = get_markup(1, 'audio')
            try:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaAudio, который является аудио.
                    media=InputMediaAudio(
                        media=LEXICON['audio_id2'],            # ID второго аудио
                        caption='Это голосовое сообщение 2'),  # Подпись ко второму аудио
                    reply_markup=markup_animation)             # Установка клавиатуры
            # В случае ошибки попытка изменить медиа на другую анимацию с соответствующим текстом
            except TelegramBadRequest:
                # Используется для редактирования существующего сообщения с медиаконтентом. Изменяет тип медиаконтента,
                # его содержимое, подпись и другие атрибуты сообщения.
                await bot.edit_message_media(
                    chat_id=callback.message.chat.id,        # ID чата
                    message_id=callback.message.message_id,  # ID сообщения
                    # Cоздается объект media типа InputMediaAnimation, который является медиа-контентом - анимацией.
                    media=InputMediaAnimation(
                        media=LEXICON['animation_id2'],  # ID второй анимации
                        caption='Это анимация 2'),       # Подпись ко второй анимации
                    reply_markup=markup_audio)      # Установка клавиатуры

########################################################################################################################
# Хендлеры для получения file_id и file_unique_id
########################################################################################################################
# Хендлер для стикеров
@user_router.message(F.content_type == ContentType.STICKER)
async def handle_sticker(message: Message) -> None:
    """
       Обрабатывает сообщения, содержащие стикеры, отправляя информацию о file_id и file_unique_id стикера.

       Args:
           message (Message): Объект сообщения, содержащего стикер.

       Returns:
           None

       Описание:
           Эта функция вызывается, когда пользователь отправляет сообщение, содержащее стикер. Она извлекает информацию
           о file_id и file_unique_id стикера из сообщения и отправляет эту информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отправляет ответ на сообщение
    await message.reply(text=f"{LEXICON_RU['ContentType.STICKER'].format(sticker_file_id=message.sticker.file_id)}\n"
                             f"{LEXICON_RU['STICKER'].format(sticker_file_unique_id=message.sticker.file_unique_id)}")
    # Отправляет в чат сообщение
    await message.answer_sticker(sticker=message.sticker.file_id)


########################################################################################################################
# Хендлер для анимации
@user_router.message(F.content_type == ContentType.ANIMATION)
async def handle_animation(message: Message) -> None:
    """
        Обрабатывает сообщения, содержащие анимации, отправляя информацию о file_id и file_unique_id анимации.

        Args:
            message (Message): Объект сообщения, содержащего анимацию.

        Returns:
            None

        Описание:
            Эта функция вызывается, когда пользователь отправляет сообщение, содержащее анимацию. Она извлекает
            информацию о file_id и file_unique_id анимации из сообщения и отправляет эту информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отправляет ответ на сообщение
    await message.reply(
        text=f"{LEXICON_RU['ContentType.ANIMATION'].format(animation_file_id=message.animation.file_id)}\n"
             f"{LEXICON_RU['ANIMATION'].format(animation_file_unique_id=message.animation.file_unique_id)}")
    # Отправляет в чат сообщение
    await message.answer_animation(animation=message.animation.file_id)


########################################################################################################################
# Хендлер для фото
@user_router.message(F.content_type == ContentType.PHOTO)
async def handle_photo(message: Message) -> None:
    """
       Обрабатывает сообщения, содержащие фотографии, отправляя информацию о file_id и file_unique_id фотографии.

       Args:
           message (Message): Объект сообщения, содержащего фотографию.

       Returns:
           None

       Описание:
           Эта функция вызывается, когда пользователь отправляет сообщение, содержащее фотографию. Она извлекает
           информацию о file_id и file_unique_id фотографии из сообщения и отправляет эту информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отвечаем на сообщение
    await message.reply(text=f"{LEXICON_RU['ContentType.PHOTO'].format(photo_file_id=message.photo[-1].file_id)}\n"
                             f"{LEXICON_RU['PHOTO'].format(photo_file_unique_id=message.photo[-1].file_unique_id)}")
    # Отправляем фотографию в чат
    await message.answer_photo(photo=message.photo[-1].file_id)


########################################################################################################################
# Хендлер для видео
@user_router.message(F.content_type == ContentType.VIDEO)
async def handle_video(message: Message) -> None:
    """
       Обрабатывает сообщения, содержащие видео, отправляя информацию о file_id и file_unique_id видео.

       Args:
           message (Message): Объект сообщения, содержащего видео.

       Returns:
           None

       Описание:
           Эта функция вызывается, когда пользователь отправляет сообщение, содержащее видео. Она извлекает информацию
           о file_id и file_unique_id видео из сообщения и отправляет эту информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отвечаем на сообщение
    await message.reply(text=f"{LEXICON_RU['ContentType.VIDEO'].format(video_file_id=message.video.file_id)}\n"
                             f"{LEXICON_RU['VIDEO'].format(video_file_unique_id=message.video.file_unique_id)}")
    # Отправляем видео в чат
    await message.answer_video(video=message.video.file_id)


########################################################################################################################
# Хендлер для видео-заметок
@user_router.message(F.content_type == ContentType.VIDEO_NOTE)
async def handle_video_note(message: Message) -> None:
    """
        Обрабатывает сообщения, содержащие видео-заметки, отправляя информацию о file_id и file_unique_id видео-заметки.

        Args:
            message (Message): Объект сообщения, содержащего видео-заметку.

        Returns:
            None

        Описание:
            Эта функция вызывается, когда пользователь отправляет сообщение, содержащее видео-заметку. Она извлекает
            информацию о file_id и file_unique_id видео-заметки из сообщения и отправляет эту информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отвечаем на сообщение
    await message.reply(
        text=f"{LEXICON_RU['ContentType.VIDEO_NOTE'].format(video_note_file_id=message.video_note.file_id)}\n"
             f"{LEXICON_RU['VIDEO_NOTE'].format(video_note_file_unique_id=message.video_note.file_unique_id)}")
    # Отправляем видео-заметку в чат
    await message.answer_video_note(video_note=message.video_note.file_id)


########################################################################################################################
# Хендлер для аудиофайлов
@user_router.message(F.content_type == ContentType.AUDIO)
async def handle_audio(message: Message) -> None:
    """
        Обрабатывает сообщения, содержащие аудиофайлы, отправляя информацию о file_id и file_unique_id аудиофайла.

        Args:
            message (Message): Объект сообщения, содержащего аудиофайл.

        Returns:
            None

        Описание:
            Эта функция вызывается, когда пользователь отправляет сообщение, содержащее аудиофайл. Она извлекает
            информацию о file_id и file_unique_id аудиофайла из сообщения и отправляет эту информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отвечаем на сообщение
    await message.reply(text=f"{LEXICON_RU['ContentType.AUDIO'].format(audio_file_id=message.audio.file_id)}\n"
                             f"{LEXICON_RU['AUDIO'].format(audio_file_unique_id=message.audio.file_unique_id)}")
    # Отправляем аудиофайл в чат
    await message.answer_audio(audio=message.audio.file_id)


########################################################################################################################
# Хендлер для голосовых сообщений
@user_router.message(F.content_type == ContentType.VOICE)
async def handle_voice(message: Message) -> None:
    """
        Обрабатывает сообщения, содержащие голосовые сообщения, отправляя информацию о file_id и file_unique_id
        голосового сообщения.

        Args:
            message (Message): Объект сообщения, содержащего голосовое сообщение.

        Returns:
            None

        Описание:
            Эта функция вызывается, когда пользователь отправляет сообщение, содержащее голосовое сообщение. Она
            извлекает информацию о file_id и file_unique_id голосового сообщения из сообщения и отправляет эту
            информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отвечаем на сообщение
    await message.reply(text=f"{LEXICON_RU['ContentType.VOICE'].format(voice_file_id=message.voice.file_id)}\n"
                             f"{LEXICON_RU['VOICE'].format(voice_file_unique_id=message.voice.file_unique_id)}")
    # Отправляем голосовое сообщение в чат
    await message.answer_voice(voice=message.voice.file_id)


########################################################################################################################
# Хендлер для документов
@user_router.message(F.content_type == ContentType.DOCUMENT)
async def handle_document(message: Message) -> None:
    """
        Обрабатывает сообщения, содержащие документы, отправляя информацию о file_id и file_unique_id документа.

        Args:
            message (Message): Объект сообщения, содержащего документ.

        Returns:
            None

        Описание:
            Эта функция вызывается, когда пользователь отправляет сообщение, содержащее документ. Она извлекает
            информацию о file_id и file_unique_id документа из сообщения и отправляет эту информацию пользователю.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    # Отвечаем на сообщение
    await message.reply(
        text=f"{LEXICON_RU['ContentType.DOCUMENT'].format(document_file_id=message.document.file_id)}\n"
             f"{LEXICON_RU['DOCUMENT'].format(document_file_unique_id=message.document.file_unique_id)}")
    # Отправляем документ в чат
    await message.answer_document(document=message.document.file_id)


########################################################################################################################
# Этот хэндлер будет срабатывать на любые остальные сообщения.
########################################################################################################################
@user_router.message()
async def send_echo(message: Message) -> None:
    """
        Отправляет копию полученного сообщения обратно пользователю.

        Args:
            message (Message): Объект сообщения.

        Returns:
            None

        Описание:
            Эта функция вызывается, когда пользователь отправляет сообщение, которое не обработано другими хэндлерами.
            Она пытается отправить копию полученного сообщения обратно пользователю. Если не удается отправить копию,
            отправляет пользователю текст об ошибке.
    """
    # Выводим апдейт в терминал
    logger.info(message.model_dump_json(indent=4, exclude_none=True))
    try:
        # Пытаемся отправить копию полученного сообщения обратно пользователю
        await message.send_copy(chat_id=message.chat.id)
    except TypeError:
        # Если не удается отправить копию, отправляем пользователю текст об ошибке из словаря
        await message.reply(text=LEXICON_RU['no_echo'])

########################################################################################################################
