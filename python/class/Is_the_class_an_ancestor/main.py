"""Является ли класс предком

Вам дано описание наследования классов в следующем формате.
<имя класса 1> : <имя класса 2> <имя класса 3> ... <имя класса k>
Это означает, что класс 1 унаследован от класса 2, класса 3, и т. д.

Или эквивалентно записи:
class Class1(Class2, Class3 ... ClassK):
    pass
Класс A является прямым предком класса B, если B унаследован от A:

class B(A):
    pass

Класс A является предком класса B, если

•	A = B;
•	A - прямой предок B
•	существует такой класс C, что C - прямой предок B и A - предок C

Например:
class B(A):
    pass

class C(B):
    pass

# A -- предок С

Вам необходимо отвечать на запросы, является ли один класс предком другого класса

Важное примечание:
Создавать классы не требуется.
Мы просим вас промоделировать этот процесс, и понять существует ли путь от одного класса до другого.

Формат входных данных
В первой строке входных данных содержится целое число n - число классов.
В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов наследуется i-й
класс. Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от
себя (прямо или косвенно), что класс не наследуется явно от одного класса более одного раза.
В следующей строке содержится число q - количество запросов.
В следующих q строках содержится описание запросов в формате <имя класса 1> <имя класса 2>.
Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
Формат выходных данных
Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком класса 2, и "No", если не
является.

Sample Input:
4
A
B : A
C : A
D : B C
4
A B
B D
C D
D A

Sample Output:
Yes
Yes
Yes
No

Пример описания классов
 A - B - D
   \   /
     C

Ввод
A
B A
C A
D B C
2
D A
B C
"""


########################################################################################################################

class A:
    pass


class B(A):
    pass


class C(A):
    pass


class D(B, C):
    pass


# Решение №1
# Использует цикл for и range для чтения ввода и строит словарь, представляющий граф наследования классов.
# Реализует функцию is_parent для рекурсивной проверки наследования между двумя классами.
# Читает запросы и выводит "Yes" или "No" в зависимости от наличия наследования между классами.
########################################################################################################################

n = int(input("Введите количество классов: "))  # Считываем количество классов

parents = {}  # Создаём словарь, где ключами будут имена классов, а значениями - список их предков

# Это означает, что в цикле будет выполнено определенное количество итераций, которое равно значению переменной n.
# Однако, значение переменной n в данном случае может быть не нужно в теле цикла, поэтому вместо указания имени
# переменной используется символ подчеркивания _, который является допустимым идентификатором в Python и обозначает,
# что значение переменной нам не нужно и не будет использоваться внутри цикла.
for _ in range(n):  # Читаем описание наследования классов и строим словарь
    # Считываем строку и разбиваем на слова
    a = input("""Введите описание наследования классов 
    (имя_класса [имя_предка_1 имя_предка_2 ... имя_предка_i]), разделенные пробелом: """).split()
    # Если у класса нет предков, то записываем пустой список иначе записываем в список всех его предков, которые идут
    # после имени класса
    parents[a[0]] = [] if len(a) == 1 else a[2:]


# Функция для проверки наследования классов
def is_parent(child, parent):
    # Если рассматриваемый класс является предком текущего класса иначе рекурсивно ищем предков текущего класса
    return child == parent or any(map(lambda p: is_parent(p, parent), parents[child]))


q = int(input("Введите количество запросов: "))  # Считываем количество запросов
# Считываем запрос и разбиваем на два класса

for _ in range(q):
    a, b = input("Введите два имени классов, разделенных пробелом: ").split()
    # Проверяем, является ли первый класс потомком второго
    print("Yes" if is_parent(b, a) else "No")

# Решение №2
# Использует цикл for и range для чтения ввода и строит словарь, представляющий граф наследования классов.
# Реализует функцию dfs для рекурсивного поиска пути между классами.
# Читает запросы и выводит "Yes" или "No" в зависимости от наличия пути между классами.
# Выводит MRO для каждого класса.
########################################################################################################################

# Считываем количество классов
n = int(input("Введите количество классов -> "))
# Создаём пустой граф, в котором будем хранить наследование классов
graph = {}

# читаем описание наследования классов и строим граф
print("""Введите описание наследования классов в формате: 
Имя_класса : Имя_родительского_класса1 Имя_родительского_класса2 ...""")

for i in range(n):
    line = input().split()  # Считываем строку и разбиваем на слова
    cls = line[0]  # Имя текущего класса
    if len(line) > 1:  # Если у класса есть предки, то записываем их в граф
        graph[cls] = line[2:]
    else:  # Если предков нет, то создаём пустой список
        graph[cls] = []


# рекурсивный DFS для поиска пути между двумя классами
def dfs(start, end):
    if start == end:  # Если начальный и конечный классы совпадают, то мы нашли путь
        return True
    if start not in graph:  # Если начальный класс не имеет предков, то путь не найден
        return False
    for parent in graph[start]:  # Ищем путь в каждом предке начального класса
        if dfs(parent, end):
            return True
    return False  # Путь не найден


# Считываем количество запросов
q = int(input("Введите количество запросов -> "))

# обрабатываем запросы
print("Введите запросы в формате: Имя_класса_1 Имя_класса_2")
for i in range(q):
    line = input().split()  # Считываем строку и разбиваем на слова
    if dfs(line[1], line[0]):  # Если между классами существует путь, то выводим "Yes", иначе - "No"
        print("Yes")
    else:
        print("No")

# Выводим MRO для каждого класса
for cls_name in graph.keys():
    cls = globals()[cls_name]
    print(f"MRO для класса {cls_name}: {[c.__name__ for c in cls.mro()]}")


# Решение 3
# Определяет функцию check_inheritance_path, которая принимает параметры через аргументы.
# Внутри функции строится граф наследования классов и реализуется функция dfs для рекурсивного поиска пути.
# Обрабатывает запросы и возвращает список результатов.
# Читает ввод и вызывает функцию check_inheritance_path, а затем выводит результаты.
########################################################################################################################

def check_inheritance_path(n, class_inheritance, queries):
    # Создаём пустой граф, в котором будем хранить наследование классов
    graph = {}

    # читаем описание наследования классов и строим граф
    for i in range(n):
        line = class_inheritance[i].split()  # Считываем строку и разбиваем на слова
        cls = line[0]  # Имя текущего класса
        if len(line) > 1:  # Если у класса есть предки, то записываем их в граф
            graph[cls] = line[2:]
        else:  # Если предков нет, то создаём пустой список
            graph[cls] = []

    # рекурсивный DFS для поиска пути между двумя классами
    def dfs(start, end):
        if start == end:  # Если начальный и конечный классы совпадают, то мы нашли путь
            return True
        if start not in graph:  # Если начальный класс не имеет предков, то путь не найден
            return False
        for parent in graph[start]:  # Ищем путь в каждом предке начального класса
            if dfs(parent, end):
                return True
        return False  # Путь не найден

    # обрабатываем запросы
    results = []
    for query in queries:
        line = query.split()  # Считываем строку и разбиваем на слова
        if dfs(line[1],
               line[0]):  # Если между классами существует путь, то добавляем "Yes" в список результатов, иначе - "No"
            results.append("Yes")
        else:
            results.append("No")
    return results


n = int(input("Введите количество классов -> "))
class_inheritance = []
for i in range(n):
    class_inheritance.append(input("Введите описание класса и его предков -> "))
q = int(input("Введите количество запросов -> "))
queries = []
for i in range(q):
    queries.append(input("Введите два имени классов, чтобы проверить наследование -> "))

results = check_inheritance_path(n, class_inheritance, queries)
for result in results:
    print(result)


# Решение 4
# Определяет функцию find_path_between_classes для чтения ввода, построения графа и обработки запросов.
# Считывает количество классов и описание наследования, строит граф наследования классов.
# Реализует функцию dfs для рекурсивного поиска пути.
# Считывает количество запросов, обрабатывает запросы и выводит результаты.
# Выводит MRO для каждого класса.
########################################################################################################################


# Эта функция будет читать ввод, строить граф наследования, и для каждого запроса проверять, существует ли путь
# между классами. Затем, она будет выводить MRO для каждого класса, используя функцию `cls.mro

# Функция для поиска пути между классами
def find_path_between_classes():
    # Считываем количество классов
    n = int(input("Введите количество классов: "))

    # Создаём пустой граф, в котором будем хранить наследование классов
    graph = {}

    # Читаем описание наследования классов и строим граф
    print("Введите описание наследования классов в формате 'class: parent1 parent2 ...':")
    for i in range(n):
        line = input().split()  # Считываем строку и разбиваем на слова
        cls = line[0]  # Имя текущего класса
        if len(line) > 1:  # Если у класса есть предки, то записываем их в граф
            graph[cls] = line[2:]
        else:  # Если предков нет, то создаём пустой список
            graph[cls] = []

    # Рекурсивный DFS для поиска пути между двумя классами
    def dfs(start, end):
        if start == end:  # Если начальный и конечный классы совпадают, то мы нашли путь
            return True
        if start not in graph:  # Если начальный класс не имеет предков, то путь не найден
            return False
        for parent in graph[start]:  # Ищем путь в каждом предке начального класса
            if dfs(parent, end):
                return True
        return False  # Путь не найден

    # Считываем количество запросов
    q = int(input("Введите количество запросов, которые нужно обработать: "))

    # Обрабатываем запросы
    print("Введите запросы в формате 'class1 class2':")
    for i in range(q):
        line = input().split()  # Считываем строку и разбиваем на слова
        if dfs(line[1], line[0]):  # Если между классами существует путь, то выводим "Yes", иначе - "No"
            print("Yes")
        else:
            print("No")

    # Выводим MRO для каждого класса
    for cls_name in graph.keys():
        cls = globals()[cls_name]
        print(f"MRO для класса {cls_name}: {[c.__name__ for c in cls.mro()]}")


find_path_between_classes()
