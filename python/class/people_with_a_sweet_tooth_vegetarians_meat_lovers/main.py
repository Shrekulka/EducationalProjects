"""Давайте представим, что в 2020 году в Днепре проводили опрос и выявили, к какому классу люди себя относят. По
результатам опроса все люди разделились на сладкоежек, вегетарианцев и любителей мяса.

Давайте напишем программу, которая поможет нам подвести итоги опроса. Для создания программы нужно:

1.	Создать родительский класс Initialization, который состоит из:
•	метода инициализации, в который поступают аргументы: capacity - целое число, food - список из строковых названий
    еды. Если в значение capacity передаётся не целое число, вывести надпись "Количество людей должно быть целым числом"
     и не создавать для таких экземпляров атрибуты capacity и food.

2.	Создать дочерний класс Vegetarian от класса Initialization, который состоит из:
•	метода инициализации, принимающего аргументы capacity, food. Нужно создать одноименные атрибуты через вызов
    родительского метода _init
•	метода _str_, который возвращает строку формата "<capacity> людей предпочитают не есть мясо! Они предпочитают <food>"

3.	Создать дочерний класс MeatEater от класса Initialization, который состоит из:
•	метода инициализации, принимающего аргументы capacity, food. Нужно создать одноименные атрибуты через вызов
    родительского метода _init_.
•	метода _str_, который возвращает строку формата "<capacity> мясоедов в Днепре! Помимо мяса они едят еще и <food>"
4.	Создать дочерний класс SweetTooth от класса Initialization, который состоит из:
•	метода инициализации, принимающего аргументы capacity, food. Нужно создать одноименные атрибуты через вызов
    родительского метода _init_.
•	магического метода _str_, который возвращает строку формата "Сладкоежек в Днепре <capacity>. Их самая любимая еда:
    <food>"
•	магического метода _eq_, который будет позволять сравнивать экземпляры класса SweetTooth с числами и другими нашими
    классами. Если сравнение происходит с целым числом и атрибут capacity с ним совпадает, то необходимо вернуть True,
    в противном случае - False. Если же сравнение идёт с другим нашим классом (Vegetarian или MeatEater) и значения
    атрибутов capacity равны, то возвращается True, в противном случае - False. А если же сравнивается с другим типом
    данных, верните "Невозможно сравнить количество сладкоежек с <значение>"
•	магического метода _lt_. Если сравнение происходит с целым числом и количество сладкоежек (атрибут capacity) меньше,
    необходимо вернуть True, в противном случае - False. Если сравнение происходит с экземпляром одного из наших классов
    Vegetarian или MeatEater и сладкоежек меньше, то верните True, в противном случае верните False. В случае если
    сравнение идет с остальными типами данных, верните "Невозможно сравнить количество сладкоежек с «значение»"
•	магического метода _gt_. Если сравнение происходит с целым числом и количество сладкоежек больше, необходимо вернуть
    значение True, в противном же случае - False. Если сравнение происходит с другим нашим классом Vegetarian или
    MeatEater и сладкоежек больше, то верните True, в противном случае - False. В случае если сравнение идет с
    остальными типами данных, верните "Невозможно сравнить количество сладкоежек с «значение»"

v_first = Vegetarian(10000, ['Орехи', 'овощи', 'фрукты'])
print(v_first) # 10000 людей предпочитают не есть мясо! Они предпочитают ['Орехи', 'овощи', 'фрукты']
v_second - Vegetarian([23], [ nothing']) # Количество людей должно быть целым числом
m_first - MeatEater(15900, ['Жареную картошку', 'рыба'])
print(m_first) # 15000 мясоедов в Днепре! Помимо мяса они едят ещё и ['Жареную картошку', 'рыба']
s_first = SweetTooth(30000, ['Мороженое , 'Чипсы', 'ШОКОЛАД'])
print(s_first) # Сладкоежек в Днепре 30000. Их самая любимая еда: ['Мороженое', 'Чипсы', 'ШОКОЛАД']
print(s_first > v_first) # True
print(30000 == s_first) # True
print(s_first == 25000) # False
print(100000 < s_first) # False
print(100 < s_first) # True
"""


########################################################################################################################
# Объявление класса Initialization
class Initialization:
    # Инициализация объекта класса с атрибутами capacity (вместимость) и food (еда)
    def __init__(self, capacity, food):
        # Проверка, является ли capacity целым числом и неотрицательным
        if not isinstance(capacity, int) or capacity < 0:
            print("Количество людей должно быть целым числом и не отрицательным")
        else:
            # Присвоение атрибутам capacity и food соответствующих значений
            self.capacity = capacity
            self.food = food


# Класс Vegetarian наследуется от класса Initialization
class Vegetarian(Initialization):
    # Инициализация объекта класса Vegetarian с атрибутами capacity и food
    def __init__(self, capacity, food):
        # Вызов конструктора родительского класса Initialization с помощью метода super()
        super().__init__(capacity, food)

    # Переопределение метода __str__, возвращающего строку с информацией о вегетарианцах
    def __str__(self):
        return f"{self.capacity} людей предпочитают не есть мясо! Они предпочитают {self.food}"


# Класс MeatEater наследуется от класса Initialization
class MeatEater(Initialization):
    # Инициализация объекта класса MeatEater с атрибутами capacity и food
    def __init__(self, capacity, food):
        # Вызов конструктора родительского класса Initialization с помощью метода super()
        super().__init__(capacity, food)

    # Переопределение метода __str__, возвращающего строку с информацией о мясоедах
    def __str__(self):
        return f"{self.capacity} мясоедов в Днепре! Помимо мяса они едят еще и {self.food}"


# Класс SweetTooth наследуется от класса Initialization
class SweetTooth(Initialization):
    # Инициализация объекта класса SweetTooth с атрибутами capacity и food
    def __init__(self, capacity, food):
        # Вызов конструктора родительского класса Initialization с помощью метода super()
        super().__init__(capacity, food)

    # Переопределение метода __str__, возвращающего строку с информацией о сладкоежках
    def __str__(self):
        return f"Сладкоежек в Днепре {self.capacity}. Их самая любимая еда:  {self.food}"

    # Переопределение метода __eq__, сравнивающего количество сладкоежек с другим объектом
    def __eq__(self, other):
        if isinstance(other, (MeatEater, Vegetarian)):
            return self.capacity == other.capacity
        elif isinstance(other, int):
            return self.capacity == other
        else:
            raise ValueError(f"Невозможно сравнить количество сладкоежек с {self.capacity}")

    # Переопределение метода __lt__, проверяющего, является ли количество сладкоежек меньшим
    def __lt__(self, other):
        if isinstance(other, (MeatEater, Vegetarian)):
            return self.capacity < other.capacity
        elif isinstance(other, int):
            return self.capacity < other
        else:
            raise ValueError(f"Невозможно сравнить количество сладкоежек с {self.capacity}")

    # Переопределение метода __gt__, проверяющего, является ли количество сладкоежек большим
    def __gt__(self, other):
        if isinstance(other, (MeatEater, Vegetarian)):
            return self.capacity > other.capacity
        elif isinstance(other, int):
            return self.capacity > other
        else:
            raise ValueError(f"Невозможно сравнить количество сладкоежек с {self.capacity}")


########################################################################################################################

v_first = Vegetarian(10000, ['Орехи', 'овощи', 'фрукты'])
print(v_first)  # 10000 людей предпочитают не есть мясо! Они предпочитают ['Орехи', 'овощи', 'фрукты']

v_second = Vegetarian([23], [' nothing'])  # Количество людей должно быть целым числом
m_first = MeatEater(15000, ['Жареную картошку', 'рыба'])

print(m_first)  # 15000 мясоедов в Днепре! Помимо мяса они едят еще и ['Жареную картошку', 'рыба']
s_first = SweetTooth(30000, ['Мороженое', 'Чипсы', 'ШОКОЛАД'])

print(s_first)  # Сладкоежек в Днепре 30000. Их самая любимая еда:  ['Мороженое', 'Чипсы', 'ШОКОЛАД']

print(s_first > v_first)  # True

print(30000 == s_first)  # True

print(s_first == 25000)  # False

print(100000 < s_first)  # False

print(100 < s_first)  # True
