#include "pch.h"

int main()
{
// 1) Основные операции с Map и Multimap
// Контейнер Map хранит пару (уникальный ключ и значение). Упорядочивание происходит на основе ключа, значение (второй аргумент)
// подвязывается к ключу
// Упорядочивание происходит как в бинарном дереве (по ключу). Корень - это первое создание и присваивание и от него пошли
// наши листики (следующие создания и присваивания). Слева меньшее, справа - большее.
// Функция make_pair() — это родовая функция со следующим прототипом:
// template<class Ktype, class Vtype>
// pair<Ktype, Vtype>make_pair (const Ktype fit, const Vtype fiv) ;
	{
		pair<char, string> p('A', "telephone");
		cout << p.first << " - " << p.second << '\n';

		cout << "\n\n";
	}
// 2) Пример работы с контейнером Map
	{
		map<int, string> myMap;
		// добавляем значение методом insert - принимает готовую пару
		// для этого создаем пару с помощью метода - make_pair (ключ, значение)
		myMap.insert(make_pair(1, "telephone"));
		// или ручками прописать пару - myMap.insert(pair<тип,тип>(ключ, значение))
		myMap.insert(pair<int, string>(2, "TV"));
		// или с помощью метода emplace - myMap.emplace(ключ, значение);
		myMap.emplace(11, "notebook");
		// Есть результат работы метода emplace (как и у метода inset), с помощью которого можно отследить получилось ли
		// добавить элемент или нет
		auto res = myMap.emplace(22, "SM");
		// узнать есть ли какое-то значение в Map или нет - поиск осуществляется по ключу через find()
		// Метод find() возвращает итератор (указывающий на пару ключ-значение) в Map, если он смог найти элемент с таки ключом
		auto it = myMap.find(22);
		if (it != myMap.end())
		{
			cout << it->second << '\n';
		}
		else
		{
			cout << "Element not found!!!\n";
		}
		// Для контейнера Map перегружен оператор [] и внутрь он принимает такой тип данных, как ключ, и как результат
		// вернется пара этого ключа, если он там был найден
		cout << myMap[11] << '\n';
		// Через квадратные скобки можем по ключу помещать значения. Т.е. добавить новый элемент в Map или заменить по
		// ключу значение
		myMap[5] = "printer";
		// метод at - он работает подобно [] - заменяет значение элемента по ключу, но если такого ключа в Map нет - то
		// он не добавится в Map, а вызовет исключение
		myMap.at(5) = "point";
		// удалить элемент можно через метод erase по ключу
		myMap.erase(5);
		//
		// В отличие от Map - может хранить дублирующиеся ключи, а также у него не перегружен оператор [] и отсутствует
		// метод at
		multimap<string, int> multi;
		multi.emplace("Roma", 123);
		multi.emplace("Roma", 55423);
		multi.emplace("Ula", 154);
		multi.emplace("Sony", 2121);
		cout << "\n\n";
	}

// 1)
// В следующей программе на примере ассоциативного списка, предназначенного для хранения десяти пар ключ/значение,
// иллюстрируются основы использования ассоциативных списков. Ключом здесь является символ, а значением — целое. Пары
// ключ/значение хранятся следующим образом:
// А     О
// B     1
// С     2
// ...
// J     9
// Поскольку пары хранятся именно таким образом, то, когда пользователь набирает на клавиатуре ключ (т.е. одну из букв
// от А до J), программа выводит на экран соответствующее этому ключу значение.
	{
		map<char, int> m;
		// Размещение пар в ассоциативном списке
		for (int i = 0; i < 20; i++)
		{
			m.insert(pair<char, int>('A' + i, i));
			// или - m.insert(make_pair(char)('A' + i, i));
			// В данном случае, чтобы в операции сложения 'А' + i не допустить автоматического преобразования в тип int,
			// используется приведение к типу char. Во всем остальном процесс определения типов объектов выполняется
			// автоматически.
		}
		char ch;
		cout << "Введите ключ: ";
		cin >> ch;
		map<char, int>::iterator p;
		// Поиск значения по заданному ключу
		p = m.find(ch);
		if (p != m.end())
		{
			cout << p->second;
		}
		else
		{
			cout << "Такого ключа в ассоциативном списке нет\n";
		}
// Обратите внимание на использование класса-шаблона pair для образования пар ключ/значение. Типы данных, указанные в
// классе-шаблоне pair, должны соответствовать типам данных, хранящимся в ассоциативном списке.
// После того как ассоциативный список инициализирован парами ключ/значение, найти нужное значение по заданному ключу можно
// с помощью функции findQ. Функция find() возвращает итератор соответствующего ключу элемента или итератор конца
// ассоциативного списка, если указанный ключ не найден. Когда соответствующее ключу значение найдено, оно сохраняется в
// качестве второго члена класса-шаблона pair.
		cout << "\n\n";
	}
// 2)
//
	{
		map<Word, Opposite> m;
		// размещение в ассоциативном списке слов и антонимов
		m.insert(pair<Word, Opposite>(Word("да"), Opposite("нет")));
		m.insert(pair<Word, Opposite>(Word("хорошо"), Opposite("плохо")));
		m.insert(pair<Word, Opposite>(Word("влево"), Opposite("вправо")));
		m.insert(pair<Word, Opposite>(Word("вверх"), Opposite("вниз")));
		// поиск антонима по заданному слову
		char str[80];
		cout << "Введите слово: ";
		cin >> str;
		map<Word, Opposite>::iterator p;
		p = m.find(Word(str));
		if (p != m.end())
		{
			cout << "Антоним: " << p->second.get();
		}
		else
		{
			cout << "Такого слова в ассоциативном списке нет\n";
		}
	}
	return 0;
}
