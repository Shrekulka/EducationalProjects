#include "pch.h"

// Например, программы на С++ применяют стек для управления автоматическими переменными. Когда новые переменные создаются,
// они добавляются на вер·шину стека, а когда уничтожаются, то удаляются из нее.
//Давайте посмотрим на свойства стека в абстрактном смысле. Прежде всего, стек содержит множество элементов. (Это свойство
// делает его контейнером - т.е. еще более общей абстракцией.) Вдобавок стек характеризуется операциями, которые на нем
// можно выполнять:
//
//• создание пустого стека;
//• добавление элемента в вершину стека (т.е. заталкивание (push) элемента);
//• удаление элемента из вершины стека (т.е. выталкивание (рор) элемента) ;
//• проверка, полон ли стек;
//• проверка, пуст ли стек.
// Это описание может быть сопоставлено с объявлением класса, в котором общедоступные функции-члены предоставляют интерфейс,
// реализующий операции над стеком. Закрытые данные-члены будут обеспечивать хранение информации в стеке.
// Концепция класса хорошо соответствует подходу АDТ.
// Раздел private должен позаботиться о хранении данных. Например, можно использовать обычный массив, динамически распределенный
// в памяти массив либо какую-то более развитую структуру данных вроде связного списка. Однако открытый интерфейс класса
// должен скрывать точные детали представления. Наоборот, он должен быть выражен в общих понятиях, таких как создание стека,
// заталкивание элемента и т.д. В листинге 10.10 показан один из возможных подходов. Предполагается, что тип bool реализован.
// Если же это не так, то вместо bool с false и trμe можно использовать int со значениями О и 1.

int main()
{
	Stack<string> st; // создание пустого стека
	char ch;
	string po = "";
	//	А - добавление заказа, Р - обработка заказа, Q - завершение;
	cout << "Пожалуйста, введите А, чтобы добавить заказ на покупку, \n"
		 << "Р для обработки заказа(PO) или Q для выхода.\n";
	while (cin >> ch && toupper(ch) != 'Q')
	{
		while (cin.get() != '\n')
		{
			continue;
		}
		if (!isalpha(ch))
		{
			cout << '\a';
			continue;
		}
		switch (ch)
		{
		case 'A' :
		case 'a' :
			cout << "Введите номер заказа(PO) для добавления: "; //запрос номера заказа;
			cin >> po;
			if (st.isfull())
			{
				cout << "Стек уже заполнен \n"; // стек уже полон;
			}
			else
			{
				st.push(po);
			}
			break;
		case 'P':
		case 'p':
			if (st.isempty())
			{
				cout << "Стек уже пуст \n"; // стек уже пуст;
			}
			else
			{
				st.рор(po);
				cout << "Заказ РО # " << po << " вытолкнут \n"; // заказ вытолкнут;
			}
			break;
		}
		cout << "Пожалуйста, введите А, чтобы добавить заказ на покупку, \n"
			 << "Р для обработки заказа(PO) или Q для выхода. \n";
		cout << "Bye \n";
	}
	return 0;
}
