// Існує n людей, які входять і виходять з кімнати. Для кожного i ∈ {1, . . . , n} особа i входить у час ai і виходить
// у час bi (припускається, що bi > ai для всіх i), і всі ai, bi є різними. На початку дня світло в кімнаті вимикається,
// і перша особа, яка входить в кімнату, вмикає його. Щоб зекономити електроенергію, якщо особа i залишає кімнату у час
// bi і ніхто інший не знаходиться в кімнаті у час bi, то особа i вимикає світло. Наступна особа, яка входить, знову
// вмикає його. Задані значення (a1, b1), (a2, b2), . . . (an, bn), ми хочемо знайти кількість разів, коли світло
// вмикається.

// Сигнатура функції:

// int times(const std::vector<std::pair<int, int>>& persons);

// Напишіть розв'язок.
// Перевірте правильність алгоритму.
// У коментарях поясніть часову складність та просторову складність вашого алгоритму.

// Приклади:
// Вхідні дані: [(1, 5), (2, 6), (3, 7)]
// Вихід: 1

// Вхідні дані: [(11, 15), (1, 10), (2, 8), (5, 12)]
// Вихід: 1

// Вхідні дані: [(5, 7), (6, 8), (9, 10), (1, 3), (2, 4)]
// Вихід: 3

// Вхідні дані: [(1, 2), (2, 3), (3, 4)]
// Вихід: 3


// Рішення
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Просторова складність цього алгоритму залежить від розміру контейнера timestamps, який містить 2 * n елементів, де n
// - кількість осіб. Тому просторова складність алгоритму становить O(n).

// Крім того, ми використовуємо додатковий вектор persons, що містить n пар початків і кінців проміжків осіб, що також
// займає O(n) простору. Отже, загальна просторова складність алгоритму становить O(n).

// Це ефективний алгоритм, оскільки він використовує лінійну кількість додаткової пам'яті, пропорційну до кількості осіб,
// і не залежить від розміру проміжків чи максимального значення часу.

// Часова складність алгоритму складається з сортування контейнера timestamps, яке має складність O(n log n), і
// подальшого проходження по ньому з складністю O(n). Отже, загальна часова складність алгоритму становить O(n log n).

// Загальною висновком є те, що цей алгоритм є ефективним як з точки зору просторової, так і з точки зору часової
// складності.

#include <iostream>
#include <vector>
#include <algorithm>

int times(const std::vector<std::pair<int, int>>& persons) {
	std::vector<std::pair<int, bool>> timestamps;

	// Створюємо вектор timestamps, що містить початки і кінці проміжків кожної особи
	for (const auto& person : persons) {
		timestamps.emplace_back(person.first, true);  // початок проміжку
		timestamps.emplace_back(person.second, false);  // кінець проміжку
	}

	// Сортуємо timestamps за зростанням часу
	std::sort(timestamps.begin(), timestamps.end());

	int count = 0; // Змінна для підрахунку кількості разів, коли світло вмикається
	int activeCount = 0; // Змінна для відстеження кількості активних проміжків
	bool lightOn = false; // Змінна, що показує, чи світло увімкнене

	// Проходимося по timestamps і обчислюємо кількість разів, коли світло вмикається
	for (const auto& timestamp : timestamps) {
		if (timestamp.second) {
			activeCount++;
			if (!lightOn) {
				lightOn = true;
				count++;
			}
		} else {
			activeCount--;
			if (activeCount == 0) {
				lightOn = false;
			}
		}
	}

	return count; // Повертаємо кількість разів, коли світло вмикається
}

int main() {
	int n;
	std::cout << "Введіть кількість осіб: ";
	std::cin >> n;

	std::vector<std::pair<int, int>> persons;
	int start, end;
	for (int i = 0; i < n; i++) {
		std::cout << "Введіть початок і кінець проміжку для особи " << i + 1 << ": ";
		std::cin >> start >> end;
		persons.emplace_back(start, end);
	}

	int result = times(persons);
	std::cout << "Кількість разів, коли світло вмикається: " << result << std::endl;

	return 0;
}
