// Упражнение 1.21. Напишите программу entab, заменяющую строки из пробелов минимальным числом табуляций и пробелов
// таким образом, чтобы вид напечатанного текста не изменился. Используйте те же "стопы" табуляции, что и в detab. В
// случае, когда для выхода на очередной "стоп" годится один пробел, что лучше — пробел или табуляция?

#include <stdio.h>

#define TAB_WIDTH 4  // Используем именованную константу для задания ширины табуляции

int main()
{
	int character;   // Переменная для считывания символов из ввода.
	int column = 0;  // Переменная для отслеживания текущей позиции в строке
	int space_count = 0;  // Переменная для подсчета последовательных пробелов

	// Цикл, который будет выполняться до тех пор, пока символ считывается из ввода и не достигнут конец файла (EOF).
	while ((character = getchar()) != EOF)
	{
		// Если символ 'q' в начале строки, завершаем программу
		if (character == 'q') break;

		// Если встречаем пробел
		if (character == ' ')
		{
			space_count++; // Увеличиваем счетчик пробелов
			column++;      // Двигаемся к следующему символу в текущей строке.

			// Если текущая позиция соответствует "стопе" табуляции
			if (column % TAB_WIDTH == 0)
			{
				// Эта строка вычисляет, сколько пробелов нужно вывести до следующей "стопы" табуляции. Используем
				// именованную константу TAB_WIDTH, чтобы определить ширину табуляции. Здесь column % TAB_WIDTH
				// вычисляет остаток от деления column на TAB_WIDTH, чтобы понять, сколько символов осталось до
				// следующей "стопы" табуляции.
				int spaces_to_next_tab = TAB_WIDTH - (column % TAB_WIDTH);

				// Этот цикл выполняет вывод нужного количества пробелов перед символами табуляции. Мы используем
				// переменную i для подсчета итераций и вывода пробелов. После каждой итерации цикла увеличиваем column
				// на 1, чтобы переместиться к следующему символу в текущей строке. Это позволяет нам выровнять текст по
				// "стопам" табуляции, вставляя нужное количество пробелов перед табуляцией.
				for (int i = 0; i < spaces_to_next_tab; ++i)
				{
					putchar(' '); // Выводим нужное количество пробелов до табуляции
					column++;     // Двигаемся к следующему символу в текущей строке.
				}
				space_count = 0;  // Сбрасываем счетчик пробелов
			}
		}
		// Если это не пробел
		else
		{
			// Выводим символы табуляции вместо накопленных пробелов
			for (int i = 0; i < space_count; ++i)
				putchar(' ');

			space_count = 0; // Сбрасываем счетчик пробелов

			putchar(character); // Выводим текущий символ
			column++;           // Двигаемся к следующему символу в текущей строке.

			if (character == '\n') // Если встречаем символ новой строки
				column = 0; // Сбрасываем счетчик позиции
		}
	}

	return 0;
}
